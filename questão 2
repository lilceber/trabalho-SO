
import threading
import time
import random

# Recursos compartilhados
compilador = threading.Semaphore(1)   # Apenas 1 pode usar
banco_dados = threading.Semaphore(2)  # Até 2 podem usar

def programador(id):
    while True:
        print(f"[Programador {id}] está pensando...")
        time.sleep(random.uniform(1, 3))  # tempo de descanso

        print(f"[Programador {id}] quer compilar...")

        # Tenta acessar recursos
        compilador.acquire()
        print(f"[Programador {id}] conseguiu o compilador.")

        banco_dados.acquire()
        print(f"[Programador {id}] conseguiu acesso ao banco de dados.")

        # Compilação
        print(f"[Programador {id}] está compilando...\n")
        time.sleep(6)

        # Libera recursos
        print(f"\n[Programador {id}] terminou a compilação e liberou os recursos.\n")
        compilador.release()
        banco_dados.release()

# Cria e inicia threads
threads = []
for i in range(5):
    t = threading.Thread(target=programador, args=(i,))
    t.start()
    threads.append(t)

# Mantém a execução (loop infinito já está dentro da função programador)
for t in threads:
    t.join()
